<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pi Camera Live Stream</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: white;
        }
        .container { display: flex; flex-direction: column; height: 100vh; }

        .header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            backdrop-filter: blur(10px);
        }
        .header h1 { font-size: 1.2em; flex-shrink: 0; }

        .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; flex: 1; }

        input {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            width: 140px;
        }
        input::placeholder { color: rgba(255,255,255,0.5); }

        button {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .btn-connect { background: #4ade80; color: #000; }
        .btn-disconnect { background: #f87171; color: #fff; }
        .btn-refresh { background: #60a5fa; color: #fff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:hover:not(:disabled) { transform: scale(1.02); filter: brightness(1.1); }

        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: contain; background: #000; }

        .ptt-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        .btn-ptt {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(145deg, #3b82f6, #1d4ed8);
            border: 3px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .btn-ptt:active, .btn-ptt.active {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(239,68,68,0.6);
        }
        .btn-ptt .icon { font-size: 28px; margin-bottom: 2px; }
        .btn-ptt.disabled {
            opacity: 0.4;
            pointer-events: none;
            background: linear-gradient(145deg, #6b7280, #4b5563);
        }
        .btn-ptt.no-mic {
            background: linear-gradient(145deg, #6b7280, #4b5563);
            pointer-events: auto;
        }

        .mic-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(239,68,68,0.9);
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: 600;
            display: none;
        }
        .mic-indicator.active { display: block; }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px 30px;
            border-radius: 10px;
        }
        .overlay.hidden { display: none; }
        .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: #4ade80;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .status-bar {
            padding: 8px 15px;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }
        .status { display: flex; gap: 15px; flex-wrap: wrap; }
        .status span { display: flex; align-items: center; gap: 5px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot-green { background: #4ade80; }
        .dot-red { background: #f87171; }
        .dot-yellow { background: #fbbf24; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .fullscreen-btn { background: rgba(255,255,255,0.2); color: white; padding: 6px 10px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pi Camera</h1>
            <div class="controls">
                <input type="text" id="streamId" placeholder="Stream ID" value="pi-camera-stream">
                <button class="btn-connect" id="connectBtn" onclick="connect()">Connect</button>
                <button class="btn-disconnect" id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
                <button class="btn-refresh" id="refreshBtn" onclick="refresh()" disabled>Refresh</button>
                <button class="fullscreen-btn" onclick="toggleFullscreen()">Fullscreen</button>
            </div>
        </div>

        <div class="video-container">
            <video id="video" autoplay playsinline muted></video>
            <div id="overlay" class="overlay hidden">
                <div class="spinner"></div>
                <div id="overlayText">Connecting...</div>
            </div>
            <div id="micIndicator" class="mic-indicator">Transmitting...</div>
            <div class="ptt-container">
                <button id="pttBtn" class="btn-ptt disabled no-mic"
                    onmousedown="startTalk()" onmouseup="stopTalk()" onmouseleave="stopTalk()"
                    ontouchstart="startTalk(event)" ontouchend="stopTalk(event)" ontouchcancel="stopTalk(event)">
                    <span class="icon">MIC</span>
                    <span>TALK</span>
                </button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status">
                <span><span id="statusDot" class="dot dot-red"></span> <span id="statusText">Disconnected</span></span>
                <span>ICE: <span id="iceState">-</span></span>
                <span>Mic: <span id="micState" onclick="requestMic()" style="cursor:pointer;text-decoration:underline">Tap to enable</span></span>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        const CONFIG = {
            RECONNECT_DELAY_MS: 2000,
            MAX_RECONNECT_ATTEMPTS: 100,
            WS_PING_INTERVAL_MS: 25000
        };

        // ============================================================================
        // STATE
        // ============================================================================
        let ws = null;
        let pc = null;
        let iceServers = null;
        let reconnectAttempts = 0;
        let lastStreamId = '';
        let isConnected = false;
        let reconnectTimer = null;
        let wsPingTimer = null;

        // Microphone state
        let localStream = null;
        let audioTrack = null;
        let micReady = false;
        let isTalking = false;

        // DOM elements
        const video = document.getElementById('video');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const iceStateEl = document.getElementById('iceState');
        const micState = document.getElementById('micState');
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlayText');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const pttBtn = document.getElementById('pttBtn');
        const micIndicator = document.getElementById('micIndicator');

        // ============================================================================
        // UI HELPERS
        // ============================================================================
        function setStatus(text, color) {
            statusText.textContent = text;
            statusDot.className = 'dot dot-' + color;
        }

        function showOverlay(text) {
            overlayText.textContent = text;
            overlay.classList.remove('hidden');
        }

        function hideOverlay() {
            overlay.classList.add('hidden');
        }

        function updateButtons(connected) {
            connectBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            refreshBtn.disabled = !connected;
            if (connected && micReady) {
                pttBtn.classList.remove('disabled');
            } else {
                pttBtn.classList.add('disabled');
            }
        }

        function log(tag, msg, data) {
            const ts = new Date().toISOString().substr(11, 12);
            if (data) {
                console.log(`[${ts}] [${tag}] ${msg}`, data);
            } else {
                console.log(`[${ts}] [${tag}] ${msg}`);
            }
        }

        // ============================================================================
        // MICROPHONE
        // ============================================================================
        async function requestMic() {
            log('MIC', 'Requesting microphone permission');

            // Check secure context
            const isSecure = window.isSecureContext ||
                             location.protocol === 'https:' ||
                             location.hostname === 'localhost' ||
                             location.hostname === '127.0.0.1';

            if (!isSecure) {
                log('MIC', 'Not in secure context');
                micState.textContent = 'Need HTTPS';
                return false;
            }

            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log('MIC', 'getUserMedia not available');
                micState.textContent = 'Not supported';
                return false;
            }

            try {
                // Request audio with simple constraints first
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioTrack = localStream.getAudioTracks()[0];

                if (audioTrack) {
                    audioTrack.enabled = false; // Start muted
                    micReady = true;
                    pttBtn.classList.remove('no-mic');
                    if (isConnected) {
                        pttBtn.classList.remove('disabled');
                    }
                    micState.textContent = 'Ready';
                    log('MIC', 'Microphone ready: ' + audioTrack.label);

                    // Add to peer connection if already connected
                    if (pc && pc.connectionState === 'connected') {
                        addAudioTrackToPeerConnection();
                    }
                    return true;
                }
            } catch (e) {
                log('MIC', 'Permission error: ' + e.name);
                if (e.name === 'NotAllowedError') {
                    micState.textContent = 'Denied';
                } else if (e.name === 'NotFoundError') {
                    micState.textContent = 'No mic found';
                } else {
                    micState.textContent = 'Error';
                }
            }
            return false;
        }

        function addAudioTrackToPeerConnection() {
            if (!pc || !audioTrack || !localStream) return;

            try {
                const senders = pc.getSenders();
                const hasAudio = senders.some(s => s.track && s.track.kind === 'audio');
                if (!hasAudio) {
                    pc.addTrack(audioTrack, localStream);
                    log('MIC', 'Audio track added to peer connection');
                }
            } catch (e) {
                log('MIC', 'Failed to add audio track: ' + e.message);
            }
        }

        function startTalk(event) {
            if (event) event.preventDefault();

            if (!micReady) {
                // Try to get mic permission on first tap
                requestMic().then(granted => {
                    if (granted && pc) {
                        addAudioTrackToPeerConnection();
                    }
                });
                return;
            }

            if (!isConnected || !audioTrack) return;

            isTalking = true;
            audioTrack.enabled = true;
            pttBtn.classList.add('active');
            micIndicator.classList.add('active');
            micState.textContent = 'Talking';
            log('MIC', 'PTT started');
        }

        function stopTalk(event) {
            if (event) event.preventDefault();
            if (!audioTrack) return;

            isTalking = false;
            audioTrack.enabled = false;
            pttBtn.classList.remove('active');
            micIndicator.classList.remove('active');
            if (micReady) {
                micState.textContent = 'Ready';
            }
            log('MIC', 'PTT stopped');
        }

        // ============================================================================
        // WEBRTC
        // ============================================================================
        function cleanup(keepMic = false) {
            log('CLEANUP', 'Cleaning up, keepMic=' + keepMic);

            if (pc) {
                pc.ontrack = null;
                pc.onicecandidate = null;
                pc.oniceconnectionstatechange = null;
                pc.onconnectionstatechange = null;
                try { pc.close(); } catch (e) {}
                pc = null;
            }

            if (video.srcObject) {
                try {
                    video.srcObject.getTracks().forEach(t => t.stop());
                } catch (e) {}
                video.srcObject = null;
            }

            if (ws) {
                if (wsPingTimer) {
                    clearInterval(wsPingTimer);
                    wsPingTimer = null;
                }
                ws.onopen = null;
                ws.onmessage = null;
                ws.onerror = null;
                ws.onclose = null;
                try { ws.close(); } catch (e) {}
                ws = null;
            }

            if (!keepMic && localStream) {
                try {
                    localStream.getTracks().forEach(t => t.stop());
                } catch (e) {}
                localStream = null;
                audioTrack = null;
                micReady = false;
                pttBtn.classList.add('no-mic', 'disabled');
                micState.textContent = 'Tap to enable';
            }

            iceStateEl.textContent = '-';
            isConnected = false;
        }

        async function handleOffer(sdp, streamId) {
            log('OFFER', 'Received offer from ' + streamId);

            pc = new RTCPeerConnection({
                iceServers: iceServers || [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            // Add audio track if available
            if (audioTrack && localStream) {
                log('OFFER', 'Adding audio track to new peer connection');
                try {
                    pc.addTrack(audioTrack, localStream);
                } catch (e) {
                    log('OFFER', 'Add track error: ' + e.message);
                }
            }

            // Handle incoming tracks
            pc.ontrack = (event) => {
                log('TRACK', 'Received ' + event.track.kind + ' track');

                if (event.track.kind === 'video' && event.streams[0]) {
                    video.srcObject = event.streams[0];

                    // Try to play
                    video.play().then(() => {
                        log('VIDEO', 'Playing');
                    }).catch(err => {
                        log('VIDEO', 'Play error, trying muted: ' + err.name);
                        video.muted = true;
                        video.play().catch(e => log('VIDEO', 'Muted play failed: ' + e.name));
                    });

                    // Mark connected
                    isConnected = true;
                    reconnectAttempts = 0;
                    setStatus('Connected', 'green');
                    updateButtons(true);
                    hideOverlay();
                }
            };

            // ICE state
            pc.oniceconnectionstatechange = () => {
                const state = pc.iceConnectionState;
                iceStateEl.textContent = state;
                log('ICE', 'State: ' + state);

                if (state === 'failed' || state === 'disconnected') {
                    handleConnectionLoss('ICE ' + state);
                }
            };

            pc.onconnectionstatechange = () => {
                log('PC', 'Connection state: ' + pc.connectionState);
                if (pc.connectionState === 'failed') {
                    handleConnectionLoss('Connection failed');
                }
            };

            // Send ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        to: streamId,
                        candidate: event.candidate.candidate,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    }));
                }
            };

            // Set remote and create answer
            try {
                await pc.setRemoteDescription({ type: 'offer', sdp: sdp });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'answer',
                        to: streamId,
                        sdp: answer.sdp
                    }));
                }
                log('OFFER', 'Answer sent');
            } catch (e) {
                log('ERROR', 'Processing offer: ' + e.message);
                handleConnectionLoss('Offer processing failed');
            }
        }

        function handleConnectionLoss(reason) {
            log('LOSS', reason);

            if (!lastStreamId) return; // User disconnected manually

            isConnected = false;
            setStatus('Reconnecting...', 'yellow');
            updateButtons(false);
            showOverlay(reason + ' - Reconnecting...');

            cleanup(true); // Keep mic for reconnect

            if (reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                const delay = Math.min(CONFIG.RECONNECT_DELAY_MS * Math.ceil(reconnectAttempts / 3), 10000);
                log('RECONNECT', `Attempt ${reconnectAttempts} in ${delay}ms`);

                reconnectTimer = setTimeout(() => {
                    document.getElementById('streamId').value = lastStreamId;
                    connect();
                }, delay);
            } else {
                setStatus('Disconnected', 'red');
                updateButtons(false);
                hideOverlay();
            }
        }

        // ============================================================================
        // CONNECTION
        // ============================================================================
        async function connect() {
            const streamId = document.getElementById('streamId').value.trim();
            if (!streamId) {
                alert('Enter stream ID');
                return;
            }

            lastStreamId = streamId;
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            cleanup(true);

            setStatus('Connecting...', 'yellow');
            updateButtons(false);
            showOverlay('Connecting...');

            // Request mic permission in background
            if (!micReady) {
                requestMic().catch(() => {});
            }

            // Get TURN credentials
            try {
                const res = await fetch('/turn-credentials');
                if (res.ok) {
                    const data = await res.json();
                    iceServers = data.iceServers;
                    log('TURN', 'Credentials fetched');
                }
            } catch (e) {
                log('TURN', 'Failed to fetch credentials');
                iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
            }

            // Connect WebSocket
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}`);

            ws.onopen = () => {
                log('WS', 'Connected');
                ws.send(JSON.stringify({ type: 'join', stream_id: streamId }));

                // Start ping interval
                wsPingTimer = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'ping' }));
                    }
                }, CONFIG.WS_PING_INTERVAL_MS);
            };

            ws.onmessage = async (e) => {
                try {
                    const data = JSON.parse(e.data);
                    log('MSG', data.type);

                    switch (data.type) {
                        case 'joined':
                            log('MSG', 'Joined as ' + data.viewer_id);
                            showOverlay('Waiting for stream...');
                            break;

                        case 'offer':
                            await handleOffer(data.sdp, data.from);
                            break;

                        case 'ice-candidate':
                            if (pc && data.candidate) {
                                try {
                                    await pc.addIceCandidate({
                                        candidate: data.candidate,
                                        sdpMLineIndex: data.sdpMLineIndex
                                    });
                                } catch (e) {
                                    log('ICE', 'Add candidate error: ' + e.message);
                                }
                            }
                            break;

                        case 'broadcaster-left':
                            handleConnectionLoss('Stream ended');
                            break;

                        case 'error':
                            handleConnectionLoss(data.message || 'Server error');
                            break;
                    }
                } catch (err) {
                    log('ERROR', 'Message parse error: ' + err.message);
                }
            };

            ws.onerror = () => {
                log('WS', 'Error');
                handleConnectionLoss('Connection error');
            };

            ws.onclose = (e) => {
                log('WS', 'Closed: ' + e.code);
                if (isConnected || lastStreamId) {
                    handleConnectionLoss('Connection lost');
                }
            };
        }

        function disconnect() {
            log('DISCONNECT', 'User initiated');
            lastStreamId = '';
            reconnectAttempts = CONFIG.MAX_RECONNECT_ATTEMPTS;

            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            cleanup(false);

            setStatus('Disconnected', 'red');
            updateButtons(false);
            hideOverlay();
        }

        function refresh() {
            log('REFRESH', 'User initiated');
            if (!isConnected && !lastStreamId) return;

            reconnectAttempts = 0;

            cleanup(true);

            setStatus('Reconnecting...', 'yellow');
            updateButtons(false);
            showOverlay('Reconnecting...');

            setTimeout(connect, 300);
        }

        function toggleFullscreen() {
            const container = document.querySelector('.video-container');
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                container.requestFullscreen().catch(() => {});
            }
        }

        // ============================================================================
        // VISIBILITY HANDLING
        // ============================================================================
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && !isConnected && lastStreamId) {
                log('VISIBILITY', 'Page visible, reconnecting');
                reconnectAttempts = 0;
                setTimeout(connect, 500);
            }
        });

        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300 && e.target.closest('.video-container') && !e.target.closest('button')) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => cleanup(false));

        // ============================================================================
        // INIT
        // ============================================================================
        log('INIT', 'Viewer ready');
        log('INIT', 'Secure context: ' + (window.isSecureContext || location.protocol === 'https:'));

        // Auto-request mic after short delay
        setTimeout(() => {
            log('INIT', 'Auto-requesting mic');
            requestMic();
        }, 1500);
    </script>
</body>
</html>
